/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/datasetSampleCreator.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/canvasManager.js":
/*!******************************!*\
  !*** ./src/canvasManager.js ***!
  \******************************/
/*! exports provided: CanvasManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CanvasManager\", function() { return CanvasManager; });\nclass CanvasManager {\n  constructor(layers, width, height, scale, colors, drawWidths) {\n    this.width = width;\n    this.height = height;\n    this.scale = scale;\n    this.colors = colors;\n    this.drawWidths = drawWidths;\n    this.cleared = true;\n    this.div = document.createElement(\"div\");\n    this.div.style.position = \"relative\";\n    this.div.style.width = width * scale + \"px\";\n    this.div.style.height = height * scale + \"px\";\n    this.div.style.backgroundColor = \"#ccc\";\n    this.divButtons = document.createElement(\"div\");\n    this.divClearButtons = document.createElement(\"div\");\n    this.divClearButtons.style.marginTop = \"10px\";\n    const buttonClearAll = document.createElement(\"button\");\n    buttonClearAll.innerHTML = \"Clear All\";\n\n    buttonClearAll.onclick = () => {\n      this.clearAll();\n    };\n\n    buttonClearAll.style.marginRight = \"5px\";\n    this.divClearButtons.appendChild(buttonClearAll);\n    const buttonClearCurrent = document.createElement(\"button\");\n    buttonClearCurrent.innerHTML = \"Clear Current\";\n\n    buttonClearCurrent.onclick = () => {\n      this.clear(this.drawLayer);\n    };\n\n    buttonClearCurrent.style.marginRight = \"5px\";\n    this.divClearButtons.appendChild(buttonClearCurrent);\n    this.canvases = [];\n    this.ctxs = [];\n\n    for (let i = 0; i < layers; i++) {\n      this.canvases[i] = document.createElement(\"canvas\");\n      this.canvases[i].width = width;\n      this.canvases[i].height = height;\n      this.canvases[i].style.width = width * scale + \"px\";\n      this.canvases[i].style.height = height * scale + \"px\";\n      this.canvases[i].style.display = \"block\";\n      this.canvases[i].style.position = \"absolute\";\n      this.canvases[i].style.left = \"0px\";\n      this.canvases[i].style.top = \"0px\";\n      this.canvases[i].style.opacity = i == 0 ? \"1\" : \"0.5\";\n      this.ctxs[i] = this.canvases[i].getContext(\"2d\");\n      this.ctxs[i].fillStyle = \"rgba(\" + colors[i] + \",0)\";\n      this.ctxs[i].fillRect(0, 0, this.width, this.height);\n      this.div.appendChild(this.canvases[i]);\n      const buttonSwitch = document.createElement(\"button\");\n      buttonSwitch.innerHTML = \"Layer \" + (i + 1).toString();\n\n      buttonSwitch.onclick = () => {\n        this.drawLayer = i;\n      };\n\n      buttonSwitch.style.marginRight = \"5px\";\n      this.divButtons.appendChild(buttonSwitch);\n      /*const buttonClear = document.createElement(\"button\")\r\n      buttonClear.innerHTML = \"Clear \" + (i + 1).toString()\r\n      buttonClear.onclick = () => { this.clear(i) }\r\n      buttonClear.style.marginRight = \"5px\"\r\n      this.divClearButtons.appendChild(buttonClear)*/\n    }\n\n    this.mouseDown = false;\n    this.mousePos = null;\n    this.touchDown = null;\n    this.topCanvas = this.canvases[this.canvases.length - 1];\n\n    this.topCanvas.onmousedown = ev => this.onMouseDown(ev);\n\n    window.addEventListener(\"mousemove\", ev => this.onMouseMove(ev));\n    window.addEventListener(\"mouseup\", ev => this.onMouseUp(ev));\n    this.topCanvas.addEventListener(\"touchstart\", ev => this.onTouchStart(ev));\n    this.topCanvas.addEventListener(\"touchmove\", ev => this.onTouchMove(ev));\n    this.topCanvas.addEventListener(\"touchend\", ev => this.onTouchEnd(ev));\n    this.topCanvas.addEventListener(\"touchcancel\", ev => this.onTouchEnd(ev));\n\n    this.onDraw = () => {};\n\n    this.onDrawFrequent = () => {};\n\n    this.drawLayer = 0;\n  }\n\n  setOpacity(opacity) {\n    this.div.style.opacity = opacity;\n  }\n\n  appendTo(parent) {\n    parent.appendChild(this.div);\n    parent.appendChild(this.divButtons);\n    parent.appendChild(this.divClearButtons);\n  }\n\n  clearAll() {\n    this.cleared = true;\n\n    for (let i = 0; i < this.canvases.length; i++) this.clear(i);\n  }\n\n  clear(layer) {\n    const ctx = this.ctxs[layer];\n    ctx.fillStyle = \"rgba(\" + this.colors[layer] + \",0)\";\n    ctx.clearRect(0, 0, this.width, this.height);\n    ctx.fillRect(0, 0, this.width, this.height);\n    this.onDraw();\n  }\n\n  copyTo(manager, layer) {\n    manager.ctxs[layer].drawImage(this.canvases[this.drawLayer], 0, 0);\n  }\n\n  getData(layer) {\n    let data = {\n      width: this.width,\n      height: this.height,\n      data: []\n    };\n    return this.canvases[layer].toDataURL(\"image/png\"); //.getImageData(0, 0, this.width, this.height)\n  }\n\n  getImageData(layer) {\n    return this.ctxs[layer].getImageData(0, 0, this.width, this.height);\n  }\n\n  putImageDataBuffer(layer, w, h, data) {\n    let imageData = this.ctxs[layer].createImageData(w, h);\n\n    for (let i = 0; i < data.length; i++) imageData.data[i] = data[i];\n\n    this.ctxs[layer].putImageData(imageData, 0, 0);\n  }\n\n  getMousePos(ev) {\n    const rect = this.topCanvas.getBoundingClientRect();\n    return {\n      x: (ev.clientX - rect.left) / this.scale,\n      y: (ev.clientY - rect.top) / this.scale\n    };\n  }\n\n  onMouseDown(ev) {\n    ev.preventDefault();\n\n    if (!this.mouseDown) {\n      this.mouseDown = true;\n      this.mousePos = this.getMousePos(ev);\n      this.drawStroke(this.mousePos, {\n        x: this.mousePos.x + 0.1,\n        y: this.mousePos.y\n      });\n    }\n  }\n\n  onMouseMove(ev) {\n    ev.preventDefault();\n\n    if (this.mouseDown) {\n      const mousePosPrev = this.mousePos;\n      this.mousePos = this.getMousePos(ev);\n      this.drawStroke(mousePosPrev, this.mousePos);\n    }\n  }\n\n  onMouseUp(ev) {\n    ev.preventDefault();\n\n    if (this.mouseDown) {\n      this.mouseDown = false;\n      const mousePosPrev = this.mousePos;\n      this.mousePos = this.getMousePos(ev);\n      this.drawStroke(mousePosPrev, this.mousePos);\n      this.onDraw();\n    }\n  }\n\n  onTouchStart(ev) {\n    ev.preventDefault();\n\n    if (this.touchDown == null) {\n      this.touchDown = ev.touches[0].identifier;\n      this.touchPos = this.getMousePos(ev.touches[0]);\n    }\n  }\n\n  onTouchMove(ev) {\n    ev.preventDefault();\n    let touch = null;\n\n    for (const t of ev.touches) {\n      if (t.identifier == this.touchDown) touch = t;\n    }\n\n    if (touch != null) {\n      const touchPosPrev = this.touchPos;\n      this.touchPos = this.getMousePos(touch);\n      this.drawStroke(touchPosPrev, this.touchPos);\n    }\n  }\n\n  onTouchEnd(ev) {\n    ev.preventDefault();\n    let touch = null;\n\n    for (const t of ev.touches) {\n      if (t.identifier == this.touchDown) touch = t;\n    }\n\n    if (touch == null) {\n      this.touchDown = null;\n      this.onDraw();\n    }\n  }\n\n  useCtx(layer, fn) {\n    const ctx = this.ctxs[layer];\n    ctx.save();\n    ctx.globalAlpha = 1;\n    fn(ctx);\n    ctx.restore();\n  }\n\n  drawStroke(p1, p2) {\n    this.cleared = false;\n    const ctx = this.ctxs[this.drawLayer];\n    ctx.strokeStyle = \"rgba(\" + this.colors[this.drawLayer] + \",1)\";\n    ctx.lineWidth = this.drawWidths[this.drawLayer];\n    ctx.lineCap = \"round\";\n    ctx.beginPath();\n    ctx.moveTo(p1.x, p1.y);\n    ctx.lineTo(p2.x, p2.y);\n    ctx.stroke();\n    this.onDrawFrequent();\n  }\n\n}\n\n//# sourceURL=webpack:///./src/canvasManager.js?");

/***/ }),

/***/ "./src/datasetSampleCreator.js":
/*!*************************************!*\
  !*** ./src/datasetSampleCreator.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _canvasManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canvasManager.js */ \"./src/canvasManager.js\");\n/* harmony import */ var _singleChannelImage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./singleChannelImage.js */ \"./src/singleChannelImage.js\");\n/* harmony import */ var _imageAnalysis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./imageAnalysis.js */ \"./src/imageAnalysis.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\n\n\n\nlet gTable = null;\nlet gIndex = 0;\nconst IMAGE_WIDTH = 256;\nconst IMAGE_HEIGHT = 256;\nconst IMAGE_SCALE = 3;\nconst canvasManagers = [];\nconst textareaLabels = [];\n\ndocument.body.onload = function () {\n  gTable = document.createElement(\"table\");\n  document.body.appendChild(gTable);\n  gTable.style.margin = \"auto\";\n  let buttonSave = document.createElement(\"button\");\n  buttonSave.innerHTML = \"Upload (Local Server Only)\";\n  buttonSave.style.width = \"250px\";\n  buttonSave.style.height = \"80px\";\n\n  buttonSave.onclick = () => {\n    upload();\n  };\n\n  document.body.appendChild(buttonSave);\n  let buttonLoad = document.createElement(\"button\");\n  buttonLoad.innerHTML = \"Load from folder (Local Server Only)\";\n  buttonLoad.style.width = \"250px\";\n  buttonLoad.style.height = \"80px\";\n\n  buttonLoad.onclick = () => {\n    load();\n  };\n\n  document.body.appendChild(buttonLoad);\n  createRowSection(10);\n};\n\nasync function load() {\n  async function loadImage(src) {\n    return new Promise((resolve, reject) => {\n      let img = document.createElement(\"img\");\n      img.src = \"/ml-samples/\" + src;\n\n      img.onload = () => {\n        resolve(img);\n      };\n\n      img.onerror = () => {\n        resolve(null);\n      };\n    });\n  }\n\n  let i = 0;\n\n  while (true) {\n    const imgIn = await loadImage(i + \".in.png\");\n    const imgOut = await loadImage(i + \".out.png\");\n    if (!imgIn || !imgOut) break;\n    if (i >= canvasManagers.length) createRowSection(10);\n    canvasManagers[i].useCtx(0, ctx => ctx.drawImage(imgIn, 0, 0));\n    canvasManagers[i].useCtx(1, ctx => ctx.drawImage(imgOut, 0, 0));\n    canvasManagers[i].cleared = false;\n    canvasManagers[i].onDraw();\n    i++;\n  }\n}\n\nasync function upload() {\n  for (let c = 0; c < canvasManagers.length; c++) {\n    const canvas = canvasManagers[c];\n    const textarea = textareaLabels[c];\n    if (canvas.cleared) continue;\n    let jsonData = {\n      components: []\n    };\n    const imageData = canvas.getImageData(1);\n    const img = _singleChannelImage_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromImageData(imageData);\n    const rects = _imageAnalysis_js__WEBPACK_IMPORTED_MODULE_2__[\"findRegions\"](img);\n    const lines = textarea.value.split(\"\\n\");\n\n    for (let r = 0; r < rects.length; r++) {\n      jsonData.components.push({\n        rect: rects[r],\n        kind: lines[r]\n      });\n    }\n\n    const data = {\n      input: canvas.getData(0),\n      output: canvas.getData(1),\n      data: JSON.stringify(jsonData)\n    };\n    await fetch(\"/upload\", {\n      method: \"post\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data)\n    }); //await new Promise((resolve, reject) => window.setTimeout(() => resolve(), 1000))\n  }\n}\n\nfunction createRowSection(rowNum) {\n  for (let i = 0; i < rowNum; i++) createRow();\n\n  let tr = document.createElement(\"tr\");\n  gTable.appendChild(tr);\n  let td = document.createElement(\"td\");\n  tr.appendChild(td);\n  let buttonMore = document.createElement(\"button\");\n  buttonMore.innerHTML = \"Create More 10 Rows\";\n  td.appendChild(buttonMore);\n\n  buttonMore.onclick = () => {\n    gTable.removeChild(tr);\n    createRowSection(10);\n  };\n}\n\nfunction createRow() {\n  let tr = document.createElement(\"tr\");\n  gTable.appendChild(tr);\n  let td = [];\n\n  for (let i = 0; i < 4; i++) {\n    td[i] = document.createElement(\"td\");\n    tr.appendChild(td[i]);\n  }\n\n  let spanInfo = document.createElement(\"span\");\n  spanInfo.innerHTML = \"Image #\" + gIndex;\n  td[0].appendChild(spanInfo);\n  let canvas = new _canvasManager_js__WEBPACK_IMPORTED_MODULE_0__[\"CanvasManager\"](4, IMAGE_WIDTH, IMAGE_HEIGHT, IMAGE_SCALE, [\"0,0,0\", \"255,0,0\", \"0,255,0\", \"0,0,255\"], [1, 8, 8]);\n  canvas.appendTo(td[1]);\n  canvasManagers.push(canvas);\n  let textareaLabel = document.createElement(\"textarea\");\n  td[3].appendChild(textareaLabel);\n  textareaLabel.style.width = \"250px\";\n  textareaLabel.style.height = \"120px\";\n  textareaLabel.placeholder = \"\";\n  textareaLabels.push(textareaLabel);\n  canvas.onDraw = Object(_utils_js__WEBPACK_IMPORTED_MODULE_3__[\"debounce\"])(() => updateRegions(canvas, textareaLabel));\n  gIndex++;\n}\n\nfunction updateRegions(canvas, textarea) {\n  const imageData = canvas.getImageData(1);\n  const img = _singleChannelImage_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromImageData(imageData);\n  const rects = _imageAnalysis_js__WEBPACK_IMPORTED_MODULE_2__[\"findRegions\"](img);\n  canvas.useCtx(3, ctx => {\n    ctx.strokeStyle = \"#00f\";\n    ctx.fillStyle = \"#00f\";\n    ctx.font = \"15px Verdana\";\n    ctx.clearRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);\n\n    for (let r = 0; r < rects.length; r++) {\n      const rect = rects[r];\n      ctx.strokeRect(rect.xMin, rect.yMin, rect.xMax - rect.xMin, rect.yMax - rect.yMin);\n      ctx.fillText(r.toString(), rect.xMax + 5, (rect.yMin + rect.yMax) / 2);\n    }\n  });\n}\n\n//# sourceURL=webpack:///./src/datasetSampleCreator.js?");

/***/ }),

/***/ "./src/imageAnalysis.js":
/*!******************************!*\
  !*** ./src/imageAnalysis.js ***!
  \******************************/
/*! exports provided: findRegions, findTrails, segmentTrails */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findRegions\", function() { return findRegions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findTrails\", function() { return findTrails; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"segmentTrails\", function() { return segmentTrails; });\n/* harmony import */ var _pointCloud2d_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pointCloud2d.js */ \"./src/pointCloud2d.js\");\n\nconst searchRadius = 20;\nconst ignoreRadius = 6;\n\nfunction distSqr(x1, y1, x2, y2) {\n  const xDist = x1 - x2;\n  const yDist = y1 - y2;\n  return xDist * xDist + yDist * yDist;\n}\n\nfunction findRegions(img, thresholdBegin = 0.85, thresholdEnd = 0.5, minArea = 50) {\n  let rects = [];\n\n  for (let j = 0; j < img.h; j++) for (let i = 0; i < img.w; i++) {\n    let alreadyContained = false;\n\n    for (const rect of rects) {\n      if (i >= rect.xMin && i <= rect.xMax && j >= rect.yMin && j <= rect.yMax) alreadyContained = true;\n    }\n\n    if (!alreadyContained && img.get(i, j) > thresholdBegin) {\n      let rect = {\n        xMin: i,\n        xMax: i,\n        yMin: j,\n        yMax: j\n      };\n      let set = new Set();\n      findRegionRecurisve(img, set, i, j, (c, x, y) => {\n        if (c < thresholdEnd) return false;\n        rect.xMin = Math.min(rect.xMin, x);\n        rect.xMax = Math.max(rect.xMax, x);\n        rect.yMin = Math.min(rect.yMin, y);\n        rect.yMax = Math.max(rect.yMax, y);\n        return true;\n      });\n      if ((rect.xMax - rect.xMin) * (rect.yMax - rect.yMin) > minArea) rects.push(rect);\n    }\n  }\n\n  return rects;\n}\n\nfunction findRegionRecurisve(img, set, x, y, filterFn) {\n  if (x < 0 || x >= img.w || y < 0 || y >= img.h) return;\n  if (set.has(y * img.w + x)) return;\n  set.add(y * img.w + x);\n\n  if (filterFn(img.get(x, y), x, y)) {\n    findRegionRecurisve(img, set, x - 1, y + 0, filterFn);\n    findRegionRecurisve(img, set, x + 1, y + 0, filterFn);\n    findRegionRecurisve(img, set, x + 0, y - 1, filterFn);\n    findRegionRecurisve(img, set, x + 0, y + 1, filterFn);\n  }\n}\n\nfunction findTrails(img, rects) {\n  let trails = [];\n\n  for (const rect of rects) {\n    for (let x = rect.xMin; x < rect.xMax; x++) {\n      findTrailsRecursive(img, rects, trails, x, rect.yMin - 1, x, rect.yMin - 1, true);\n      findTrailsRecursive(img, rects, trails, x, rect.yMax + 1, x, rect.yMax + 1, true);\n    }\n\n    for (let y = rect.yMin; y < rect.yMax; y++) {\n      findTrailsRecursive(img, rects, trails, rect.xMin - 1, y, rect.xMin - 1, y, true);\n      findTrailsRecursive(img, rects, trails, rect.xMax + 1, y, rect.xMax + 1, y, true);\n    }\n  }\n\n  const trailCloud = new _pointCloud2d_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n\n  for (const trail of trails) trailCloud.addPoint(trail);\n\n  for (const rect of rects) {\n    const trailU = trailCloud.findNearest((rect.xMin + rect.xMax) / 2, rect.yMin);\n    const trailD = trailCloud.findNearest((rect.xMin + rect.xMax) / 2, rect.yMax);\n    const trailL = trailCloud.findNearest(rect.xMin, (rect.yMin + rect.yMax) / 2);\n    const trailR = trailCloud.findNearest(rect.xMax, (rect.yMin + rect.yMax) / 2); //console.log(trailU, trailD, trailL, trailR)\n\n    if (trailU) trailU.connected = true;\n    if (trailD) trailD.connected = true;\n    if (trailL) trailL.connected = true;\n    if (trailR) trailR.connected = true;\n  }\n\n  for (let trail of trails) {\n    trail.links = [];\n\n    for (const nextTrail of trailCloud.enumerateNear(trail.x, trail.y, searchRadius)) {\n      if (nextTrail === trail) continue;\n      trail.links.push(nextTrail);\n    }\n  }\n\n  trails = filterTopologicallyUsefulTrails(trails);\n  trails.forEach((trail, i) => {\n    trail.id = i;\n  });\n  improveTrailLinks(trails);\n  trails = filterTopologicallyUsefulTrails(trails);\n  trails.forEach(t => t.links = [...new Set(t.links)]);\n  return trails;\n}\n\nfunction improveTrailLinks(trails) {\n  for (let trail of trails) {\n    //console.log(\"--\")\n    //console.log(\"trail\", trail.id)\n    while (true) {\n      let hadReconnection = false;\n\n      for (let nextTrail of [...trail.links]) {\n        const score = (x1, y1, x2, y2) => {\n          const straightness = Math.min(Math.abs(x2 - x1), Math.abs(y2 - y1));\n          const d = distSqr(x1, y1, x2, y2);\n          return d * (straightness + 1);\n        }; //console.log(\"    > next\", nextTrail.id)\n\n\n        let bestConnection = nextTrail;\n\n        for (let nextNextTrail of nextTrail.links) {\n          if (nextNextTrail === trail || nextNextTrail === nextTrail) continue;\n          const nextNextScore = score(trail.x, trail.y, nextNextTrail.x, nextNextTrail.y);\n          const bestScore = score(trail.x, trail.y, bestConnection.x, bestConnection.y); //console.log(\"        nextNext\", nextNextTrail.id, nextNextScore, bestScore)\n\n          if (nextNextScore < bestScore) bestConnection = nextNextTrail;\n        } //console.log(\"    best\", bestConnection.id)\n\n\n        if (bestConnection !== nextTrail) {\n          nextTrail.links = nextTrail.links.filter(t => t !== trail);\n          trail.links = trail.links.filter(t => t !== nextTrail);\n          bestConnection.links.push(trail);\n          trail.links.push(bestConnection);\n          if (trail.worseLinks) trail.worseLinks.push(nextTrail); //console.log(\"    better link found\")\n\n          hadReconnection = true;\n        }\n      }\n\n      if (!hadReconnection) break;\n    }\n  }\n}\n\nfunction findTrailsRecursive(img, rects, trails, x, y, prevX, prevY, first) {\n  for (const rect of rects) {\n    if (x > rect.xMin && x < rect.xMax && y > rect.yMin && y < rect.yMax) return;\n  }\n\n  for (const trail of trails) {\n    const xDist = x - trail.x;\n    const yDist = y - trail.y;\n    if (xDist * xDist + yDist * yDist < ignoreRadius * ignoreRadius) return;\n  }\n\n  let thisTrail = null;\n\n  if (!first) {\n    thisTrail = {\n      x,\n      y\n    };\n    trails.push(thisTrail);\n  }\n\n  let continuations = [];\n\n  for (let yy = Math.max(0, y - searchRadius); yy < Math.min(img.h, y + searchRadius); yy++) for (let xx = Math.max(0, x - searchRadius); xx < Math.min(img.w, x + searchRadius); xx++) {\n    if (distSqr(x, y, xx, yy) > searchRadius * searchRadius) continue;\n\n    if (img.get(xx, yy) > 0.5) {\n      const xDist = xx - x;\n      const yDist = yy - y;\n      continuations.push({\n        x: xx,\n        y: yy,\n        distSqr: xDist * xDist + yDist * yDist\n      });\n    }\n  }\n\n  continuations.sort((a, b) => b.distSqr - a.distSqr);\n\n  for (const continuation of continuations) findTrailsRecursive(img, rects, trails, continuation.x, continuation.y, x, y, false);\n}\n\nfunction filterTopologicallyUsefulTrails(trails) {\n  for (let trail of trails) {\n    trail.connectedLinks = [];\n    trail.worseLinks = [];\n  }\n\n  const topoSeenTrails = new Set();\n  const topoUsefulTrails = new Set();\n\n  for (const trail of trails) {\n    if (trail.connected) filterTopologicallyUsefulTrailsRecursive(trail, true, topoSeenTrails, topoUsefulTrails);\n  }\n\n  trails = trails.filter(t => t.connected || topoUsefulTrails.has(t));\n\n  for (let trail of trails) {\n    trail.links = trail.connectedLinks;\n    trail.links = trail.links.filter(t => t.connected || topoUsefulTrails.has(t));\n  }\n\n  return trails;\n}\n\nfunction filterTopologicallyUsefulTrailsRecursive(trail, isFirst, seenTrails, usefulTrails) {\n  let useful = trail.connected;\n\n  if (isFirst || !trail.connected) {\n    const sortScore = t => distSqr(t.x, t.y, trail.x, trail.y);\n\n    let sortedTrails = [...trail.links];\n    sortedTrails.sort((a, b) => sortScore(a) - sortScore(b));\n\n    for (const nextTrail of sortedTrails) {\n      if (trail.connected && nextTrail.connected) continue;\n      if (seenTrails.has(nextTrail)) continue;\n      seenTrails.add(nextTrail);\n      const nextUseful = filterTopologicallyUsefulTrailsRecursive(nextTrail, false, seenTrails, usefulTrails);\n\n      if (nextUseful) {\n        nextTrail.connectedLinks.push(trail);\n        trail.connectedLinks.push(nextTrail);\n      }\n\n      useful |= nextUseful;\n    }\n  }\n\n  if (useful) usefulTrails.add(trail);\n  return useful;\n}\n\nfunction segmentTrails(trails) {\n  const seenTrails = new Set();\n  const trailToSegmentMap = new Map();\n  let segments = [];\n\n  const dirTo = (x1, y1, x2, y2) => Math.atan2(y1 - y2, x2 - x1);\n\n  const mod = (x, m) => (x % m + m) % m;\n\n  const angleDiff = (a1, a2) => Math.abs(mod(a2 - a1 + Math.PI, Math.PI * 2) - Math.PI);\n\n  function followLineRecursive(segment, trail) {\n    if (seenTrails.has(trail)) return;\n    seenTrails.add(trail);\n\n    if (segment && segment.trails.length >= 2) {\n      const firstTrail = segment.trails[0];\n      const secondTrail = segment.trails[1];\n      const origDir = dirTo(firstTrail.x, firstTrail.y, secondTrail.x, secondTrail.y);\n      const prevTrail = segment.trails[segment.trails.length - 1];\n      const curDir = dirTo(prevTrail.x, prevTrail.y, trail.x, trail.y); //console.log(firstTrail.id, secondTrail.id, Math.floor(origDir / Math.PI * 180), \",\", prevTrail.id, trail.id, Math.floor(curDir / Math.PI * 180), \"=\", Math.floor(angleDiff(origDir, curDir) / Math.PI * 180))\n\n      if (angleDiff(origDir, curDir) > Math.PI / 4) {\n        segment = null; //console.log(\"break segment\")\n      }\n    }\n\n    if (!segment) {\n      segment = {\n        trails: []\n      };\n      segments.push(segment);\n    }\n\n    segment.trails.push(trail);\n\n    for (const link of trail.links) {\n      if (trail.links.length >= 3) {\n        segment.trails.push(link);\n        followLineRecursive(null, link, trail);\n      } else followLineRecursive(segment, link, trail);\n    }\n  }\n\n  let trailsToProcess = trails.filter(t => t.connected);\n\n  while (trailsToProcess.length > 0) {\n    const trail = trailsToProcess.pop();\n    followLineRecursive(null, trail);\n  }\n\n  return segments;\n}\n\n//# sourceURL=webpack:///./src/imageAnalysis.js?");

/***/ }),

/***/ "./src/pointCloud2d.js":
/*!*****************************!*\
  !*** ./src/pointCloud2d.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PointCloud2D; });\n/* harmony import */ var _rect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rect.js */ \"./src/rect.js\");\n\nclass PointCloud2D {\n  constructor() {\n    this.points = [];\n    this.table = null;\n    this.cellNum = 20;\n  }\n\n  addPoint(p) {\n    this.points.push(p);\n    this.table = null;\n  }\n\n  getTableCellFor(x, y) {\n    if (!this.table) throw \"not built\";\n    const xCell = Math.floor((x - this.table.xMin) / (this.table.xMax + 1 - this.table.xMin));\n    const yCell = Math.floor((y - this.table.yMin) / (this.table.yMax + 1 - this.table.yMin));\n    return {\n      x: xCell,\n      y: yCell,\n      i: yCell * this.cellNum + xCell\n    };\n  }\n\n  getTableCellRect(xCell, yCell) {\n    return new _rect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.table.xMin + xCell * (this.table.xMax - this.table.xMin) / this.cellNum, this.table.yMin + yCell * (this.table.yMax - this.table.yMin) / this.cellNum, (this.table.xMax - this.table.xMin) / this.cellNum, (this.table.yMax - this.table.yMin) / this.cellNum);\n  }\n\n  ensureBuilt() {\n    if (this.table) return;\n    let bbox = {\n      xMin: null,\n      yMin: null,\n      xMax: null,\n      yMax: null\n    };\n\n    for (const p of this.points) {\n      bbox.xMin = bbox.xMin === null ? p.x : Math.min(bbox.xMin, p.x);\n      bbox.yMin = bbox.yMin === null ? p.y : Math.min(bbox.yMin, p.y);\n      bbox.xMax = bbox.xMax === null ? p.x : Math.max(bbox.xMax, p.x);\n      bbox.yMax = bbox.yMax === null ? p.y : Math.max(bbox.yMax, p.y);\n    }\n\n    this.table = { ...bbox,\n      cells: new Array(this.cellNum * this.cellNum)\n    };\n\n    for (let i = 0; i < this.cellNum * this.cellNum; i++) this.table.cells[i] = [];\n\n    for (const p of this.points) {\n      const cell = this.getTableCellFor(p.x, p.y);\n      this.table.cells[cell.i].push(p);\n    }\n  }\n\n  *enumerateNearSlow(x, y, maxDistance) {\n    for (const p of this.points) {\n      const xDist = p.x - x;\n      const yDist = p.y - y;\n      if (xDist * xDist + yDist * yDist > maxDistance * maxDistance) continue;\n      yield p;\n    }\n  }\n\n  findNearest(x, y, maxDistance = Infinity) {\n    this.ensureBuilt();\n    if (!isFinite(maxDistance)) maxDistance = Math.max(this.table.xMax - this.table.xMin, this.table.yMax - this.table.yMin);\n    let near = [];\n\n    for (const point of this.enumerateNear(x, y, maxDistance)) near.push(point);\n\n    const distSqr = (x1, y1, x2, y2) => {\n      const xx = x2 - x1;\n      const yy = y2 - y1;\n      return xx * xx + yy * yy;\n    };\n\n    near.sort((a, b) => distSqr(a.x, a.y, x, y) - distSqr(b.x, b.y, x, y));\n    return near.length > 0 ? near[0] : null;\n  }\n\n  *enumerateNear(x, y, maxDistance) {\n    this.ensureBuilt();\n    const nearRect = new _rect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](x - maxDistance, y - maxDistance, maxDistance * 2, maxDistance * 2);\n    const centerCell = this.getTableCellFor(x, y);\n\n    if (centerCell.i >= 0 && centerCell.i < this.cellNum * this.cellNum) {\n      for (const p of this.table.cells[centerCell.i]) {\n        const xDist = p.x - x;\n        const yDist = p.y - y;\n        if (xDist * xDist + yDist * yDist > maxDistance * maxDistance) continue;\n        yield p;\n      }\n    }\n\n    for (let step = 1; step < this.cellNum; step++) {\n      let mustExpand = false;\n\n      for (let xCell = -step; xCell <= step; xCell++) for (let yCell = -step; yCell <= step; yCell += step * 2) {\n        const iCell = yCell * this.cellNum + xCell;\n        if (iCell < 0 || iCell >= this.cellNum * this.cellNum) continue;\n        if (!this.getTableCellRect(xCell, yCell).overlaps(nearRect)) continue;\n        mustExpand = true;\n\n        for (const p of this.table.cells[iCell]) {\n          const xDist = p.x - x;\n          const yDist = p.y - y;\n          if (xDist * xDist + yDist * yDist > maxDistance * maxDistance) continue;\n          yield p;\n        }\n      }\n\n      for (let yCell = -step + 1; yCell <= step - 1; yCell++) for (let xCell = -step; xCell <= step; xCell += step * 2) {\n        const iCell = yCell * this.cellNum + xCell;\n        if (iCell < 0 || iCell >= this.cellNum * this.cellNum) continue;\n        if (!this.getTableCellRect(xCell, yCell).overlaps(nearRect)) continue;\n        mustExpand = true;\n\n        for (const p of this.table.cells[iCell]) {\n          const xDist = p.x - x;\n          const yDist = p.y - y;\n          if (xDist * xDist + yDist * yDist > maxDistance * maxDistance) continue;\n          yield p;\n        }\n      }\n\n      if (!mustExpand) break;\n    }\n  }\n\n}\n\n//# sourceURL=webpack:///./src/pointCloud2d.js?");

/***/ }),

/***/ "./src/rect.js":
/*!*********************!*\
  !*** ./src/rect.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Rect; });\nclass Rect {\n  constructor(x, y, w, h) {\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n  }\n\n  static fromVertices(x1, y1, x2, y2) {\n    return new Rect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));\n  }\n\n  contains(p) {\n    return p.x >= this.x && p.x < this.x + this.w && p.y >= this.y && p.y < this.y + this.h;\n  }\n\n  overlaps(other) {\n    return this.x + this.w >= other.x && this.x < other.x + other.w && this.y + this.h >= other.y && this.y < other.y + other.h;\n  }\n\n}\n\n//# sourceURL=webpack:///./src/rect.js?");

/***/ }),

/***/ "./src/singleChannelImage.js":
/*!***********************************!*\
  !*** ./src/singleChannelImage.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SingleChannelImage; });\nfunction lerp(a, b, t) {\n  return a + (b - a) * t;\n}\n\nclass SingleChannelImage {\n  constructor(w, h, fillValue = 0) {\n    this.pixels = new Float32Array(w * h);\n    this.w = w;\n    this.h = h;\n  }\n\n  clone() {\n    const cloned = new SingleChannelImage(this.w, this.h);\n\n    for (let i = 0; i < this.w * this.h; i++) cloned.pixels[i] = this.pixels[i];\n\n    return cloned;\n  }\n\n  get(x, y, def = 0) {\n    if (x < 0 || x >= this.w || y < 0 || y >= this.h) return def;\n    return this.pixels[y * this.w + x];\n  }\n\n  getBilinear(x, y, def = 0) {\n    if (x < 0 || x >= this.w || y < 0 || y >= this.h) return def;\n    const x1 = Math.floor(x);\n    const x2 = Math.ceil(x);\n    const y1 = Math.floor(y);\n    const y2 = Math.ceil(y);\n    const xT = x - Math.floor(x);\n    const yT = y - Math.floor(y);\n    const cY1 = lerp(this.get(x1, y1), this.get(x2, y1), xT);\n    const cY2 = lerp(this.get(x1, y2), this.get(x2, y2), xT);\n    return lerp(cY1, cY2, yT);\n  }\n\n  set(x, y, value) {\n    if (x < 0 || x >= this.w || y < 0 || y >= this.h) return this;\n    const cloned = this.clone();\n    cloned.setInPlace(x, y, value);\n    return cloned;\n  }\n\n  setInPlace(x, y, value) {\n    if (x < 0 || x >= this.w || y < 0 || y >= this.h) return;\n    this.pixels[y * this.w + x] = value;\n  }\n\n  addInPlace(x, y, value) {\n    if (x < 0 || x >= this.w || y < 0 || y >= this.h) return;\n    this.pixels[y * this.w + x] += value;\n  }\n\n  some(fn) {\n    return this.pixels.some(fn);\n  }\n\n  every(fn) {\n    return this.pixels.every(fn);\n  }\n\n  forEach(fn) {\n    this.pixels.forEach(fn);\n  }\n\n  mapInPlace(fn) {\n    for (let j = 0; j < this.h; j++) for (let i = 0; i < this.w; i++) this.setInPlace(i, j, fn(this.get(i, j), i, j));\n  }\n\n  static fromArray(array, w, h) {\n    const img = new SingleChannelImage(w, h);\n\n    for (let j = 0; j < h; j++) for (let i = 0; i < w; i++) img.setInPlace(i, j, array[j * w + i]);\n\n    return img;\n  }\n\n  toArray() {\n    let array = new Array(this.w * this.h);\n\n    for (let j = 0; j < this.h; j++) for (let i = 0; i < this.w; i++) array[j * this.w + i] = this.get(i, j);\n\n    return array;\n  }\n\n  static fromImageData(imageData, channel = 3) {\n    const img = new SingleChannelImage(imageData.width, imageData.height);\n\n    for (let j = 0; j < imageData.height; j++) for (let i = 0; i < imageData.width; i++) img.setInPlace(i, j, imageData.data[(j * imageData.width + i) * 4 + channel] / 255);\n\n    return img;\n  }\n\n  toImageDataBuffer(color = [0, 0, 0]) {\n    let buffer = new Array(this.w * this.h * 4);\n\n    for (let j = 0; j < this.h; j++) for (let i = 0; i < this.w; i++) {\n      buffer[(j * this.w + i) * 4 + 0] = color[0];\n      buffer[(j * this.w + i) * 4 + 1] = color[1];\n      buffer[(j * this.w + i) * 4 + 2] = color[2];\n      buffer[(j * this.w + i) * 4 + 3] = Math.max(0, Math.min(255, this.get(i, j) * 255));\n    }\n\n    return buffer;\n  }\n\n  halfDownsample(colorGainFactor = 1) {\n    const img = new SingleChannelImage(this.w / 2, this.h / 2);\n\n    for (let j = 0; j < this.h; j++) for (let i = 0; i < this.w; i++) img.addInPlace(Math.floor(i / 2), Math.floor(j / 2), this.get(i, j));\n\n    img.mapInPlace(c => Math.min(1, c * colorGainFactor / 4));\n    return img;\n  }\n\n  doubleUpsample() {\n    const img = new SingleChannelImage(this.w * 2, this.h * 2);\n\n    for (let j = 0; j < this.h; j++) for (let i = 0; i < this.w; i++) {\n      img.setInPlace(i * 2 + 0, j * 2 + 0, this.get(i, j));\n      img.setInPlace(i * 2 + 1, j * 2 + 0, this.get(i, j));\n      img.setInPlace(i * 2 + 0, j * 2 + 1, this.get(i, j));\n      img.setInPlace(i * 2 + 1, j * 2 + 1, this.get(i, j));\n    }\n\n    return img;\n  }\n\n  mirror() {\n    const img = new SingleChannelImage(this.w, this.h);\n\n    for (let j = 0; j < this.h; j++) for (let i = 0; i < this.w; i++) img.setInPlace(i, j, this.get(this.w - i - 1, j));\n\n    return img;\n  }\n\n  rotate90Clockwise() {\n    const img = new SingleChannelImage(this.w, this.h);\n\n    for (let j = 0; j < this.h; j++) for (let i = 0; i < this.w; i++) img.setInPlace(i, j, this.get(this.h - j - 1, i));\n\n    return img;\n  }\n\n  window(windowW, windowH, windowStrideX, windowStrideY) {\n    let imgs = [];\n\n    for (let yMin = 0; yMin < this.h; yMin += windowStrideY) for (let xMin = 0; xMin < this.w; xMin += windowStrideX) {\n      let img = new SingleChannelImage(windowW, windowH);\n\n      for (let j = 0; j < this.h; j++) for (let i = 0; i < this.w; i++) img.setInPlace(i, j, this.get(xMin + i, yMin + j));\n\n      imgs.push(img);\n    }\n\n    return imgs;\n  }\n\n  static dewindow(windows, originalW, originalH, windowStrideX, windowStrideY) {\n    const img = new SingleChannelImage(originalW, originalH);\n    const weights = new SingleChannelImage(originalW, originalH);\n    const windowW = windows[0].w;\n    const windowH = windows[0].h;\n    let yMin = 0;\n    let xMin = 0;\n\n    for (let wd = 0; wd < windows.length; wd++) {\n      for (let j = 0; j < windowH; j++) for (let i = 0; i < windowW; i++) {\n        img.addInPlace(xMin + i, yMin + j, windows[wd].get(i, j));\n        weights.addInPlace(xMin + i, yMin + j, 1);\n      }\n\n      xMin += windowStrideX;\n\n      if (xMin >= originalW) {\n        xMin = 0;\n        yMin += windowStrideY;\n      }\n    }\n\n    img.mapInPlace((c, i, j) => c / weights.get(i, j));\n    return img;\n  }\n\n  crop(x1, y1, x2, y2) {\n    const newW = x2 - x1;\n    const newH = y2 - y1;\n    const img = new SingleChannelImage(newW, newH);\n\n    for (let j = 0; j < newH; j++) for (let i = 0; i < newW; i++) img.setInPlace(i, j, this.get(x1 + i, y1 + j));\n\n    return img;\n  }\n\n  stretch(newW, newH) {\n    const img = new SingleChannelImage(newW, newH);\n\n    for (let j = 0; j < newH; j++) for (let i = 0; i < newW; i++) img.setInPlace(i, j, this.getBilinear(i / newW * this.w, j / newH * this.h));\n\n    return img;\n  }\n\n}\n\n//# sourceURL=webpack:///./src/singleChannelImage.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! exports provided: debounce, shuffleArray, encodeOneHot, decodeOneHot */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"debounce\", function() { return debounce; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shuffleArray\", function() { return shuffleArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"encodeOneHot\", function() { return encodeOneHot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decodeOneHot\", function() { return decodeOneHot; });\nfunction debounce(func, wait, immediate) {\n  let timeout = null;\n  return function () {\n    let context = this;\n    let args = arguments;\n\n    let later = function () {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n\n    let callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n}\nfunction shuffleArray(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n}\nfunction encodeOneHot(index, length) {\n  let oneHot = new Array(length).fill(0);\n  oneHot[index] = 1;\n  return oneHot;\n}\nfunction decodeOneHot(oneHot) {\n  return oneHot.findIndex(i => i != 0);\n}\n\n//# sourceURL=webpack:///./src/utils.js?");

/***/ })

/******/ });